bem-data-source
===============

Инструмент для версионированной сборки документации и примеров библиотек для проектов bem-info legoa-www.

### Установка

* клонировать репозиотрий `git clone git://github.com/tormozz48/bem-data-source.git`
* перейти в директорию с выкачанным проектом `cd bem-data-source`
* подключить зависимости `npm install`
* запустить командой `node make.js`

- при запуске инструмента можно указывать разные уровни логирования добавляя флаг `-v` и возможными значениями
`silly`, `debug`, `info`, `warn`, `error`. По умолчанию выставляется уровень логгирования 'info'.

### Конфигурирование

Конфигурация сборки полностью описывается содержимым файла `config/config.json`.

* `contentDirectory` - название директории куда будут выкачиваться библиотеки при сборке
* `outputTargetFile` - имя файлов в которые будут кешироваться промежуточные результаты сборки для одной цели
* `gitAPI` - конфигурация github API для доступа к приватным и публичным репозиториям github.
* `sources` - описание репозиториев содержимое которых попадет в сборку

Объект `sources` делится на 2 группы `private` и `public`. В разделе `private` описываются репозитории, находящиеся
на внутреннем корпоративном github-е `https://github.yandex-team.ru`. В разделе  `public` описываются репозитории, находящиеся
на внешнем публичном github-е `https://github.com`.

Внутри групп `private` и `public` репозитории также группируются по критерию владельца, которыми могут быть как организации `org`,
так и отдельные люди `user`.

Библиотека для сборки оисывается в конфигурационном файле объектом вида:

```
{
    "name": "firmCardStory",
    "targetDir": "articles/firm-card-story",
    "type": ["docs"],
    "docDirs": ["docs"],
    "branches": {
        "include": ["master"],
        "exclude": []
    },
    "tags": [
        "include": [],
        "exclude": []
    ]
}
```

Здесь:

* `name` - название репозитория (должно совпадать с названием репозитория на github)
* `targetDir` - название директории куда будет склонирован проект (относительно общей папки `contentDirectory`)
* `type` - массив типов ресурсов, которые будут собраны для данного репозитория. Возможные значения: `libs`, `docs`
* `docDirs` - массив с названиями директорий в которых находятся блоки с документацией. Обычно это `docs`, `doc`, `common.docs` и.т.д
Если блоки с документацией находятся в корне проекта, то массив должен быть пустым.
* `branches` - объект с полями `include` и `exclude`, значеними которых являются массивы с именами веток `branch` которые
будут соответственно включены и исключены из сборки проекта. После успешной сборки конфигурационный файл переписывается и
в массив `exclude` добавляется имя собранной ветки.
* `tags` - объект с полями `include` и `exclude`, значеними которых являются массивы с именами тегов `tag` которые
будут соответственно включены и исключены из сборки проекта. После успешной сборки конфигурационный файл переписывается и
в массив `exclude` добавляется имя собранного тега. Значением поля `include` для тегов могут быть также строки
`all` и `last`. `all` указывает на необходимость сборки всех существующих тегов, а `last` только последнего тега.
(здесь предполагается что теги имеют структуру 0.0.0, что дает возможность их явной сортировки)

### Принцип работы

Работа инструмента может быть четко разделена на несколько последовательных шагов.

#### Шаг #1 get_sources

На этом шаге древовидный объект `sources` из конфигурационного файла превращается в плоский список элементами которого являются
объекты описывающие информацию по отдельным репозиториям, с добавлением полей владельца и логическим флагом для обозначения
типа приватности этого репозитория (корпоративный или общий github). Такая структура данных содержит всю необходимую
информацию для работы с github API в удобном виде.

#### Шаг #2 resolve_repositories

На этом шаге для каждого репозитория указанного в конфигурационном файле по названию репозитория
и владельцу происходит запрос на получение детальной информации о репозитории. Это дает возможность получить
`git_url` - ссылку по которой можно будет выполгить клонирование репозитория на локальную файловую систему.

#### Шаг #3 resolve_tags

На этом шаге для каждого репозитория указанного в конфигурационном файле по названию репозитория
и владельцу происходит запрос на получение детальной информации о существующих тегах. Полученный список
фильтруется по критерию совпадения с массивами тегов указанных в полях `include` и `exclude` в конфигурационном файле

#### Шаг #4 resolve_branches

Аналогично шагу #3 но для веток репозитория.

#### Шаг #5 create_targets

//TODO написать информацию

#### Шаг #6 execute_targets

//TODO написать информацию

#### Шаг #8 finalize

На этом шаге происходит перезапись конфигурационного файла `config/config.json`.
Теги или ветки ресурсы которых были успешно собраны добавляются в `exclude` массивы
соответствующих репозиториев и файл перезаписывается. Это дает возможность исключить повторную сборку ресурсов.

#### Шаг #9 collect_results

На этом шаге происходит окончательная сборка и компоновка собранных данных. Для всех тегов и веток репозиториев
происходит чтение закешированных промежуточных результатов сборки из файлов `__data.json`. Затем, полученные данные
объединяются в один супер-массив который является удобной структурой для нормализации данных.

Нормализация данных обозначает процесс данных по типам сущностей и генерацию связей между ними с гарантией целостности.
В настоящее время выделяются следующие сущности:

* `languages`
* `types`
* `tags`
* `authors` (включает и переводчиков тоже)
* `categories`

Объект содержащий данные в нормализованном виде с сигнатурой типа:

```
var db = {
    languages: [],
    tags: [],
    types: [],
    authors: [],
    categories: [],
    posts: [],
    libs: [],
    versions: [],
    levels: [],
    blocks: []
};
```

записывается в 2 файла: `db.json` и `db_min.json`. Первый предоставляет данные в виде удобном для чтения, а второй
- данные в минимизированном виде, что помогает сократить размер файла и ускорить его загрузку при работе фронтед-части.

### Дальнейшая работа:
* парсинг и организация иерархической структуры категорий
* выделение сущности `posts`
* организация сбора построенной документации к блокам в общие файлы  `__data.json` по версиям библиотеки
* выделение сущности `libs`
* выделение сущности `versions`
* выделение сущности `levels`
* выделение сущности `blocks`
* организация связи между `posts` и `libs` (подумать вместе)

Ответственный за разработку @bemer

Вопросы и пожелания присылать по адресу: bemer@yandex-team.ru
